# Дата - 2025-10-30

Tags: #спортивное_программирование #графы #реализация #биты #битовые_маски

---
## О чём задача:

Дан неориентированный граф. В каждую вершину можем положить любое число. Нужно посчитать количество перестановок таких чисел, что в каждой вершине будет храниться mex среди всех её соседей. Это значит, что если в вершине лежит число k, то в его соседях должны лежать число от 0 до k - 1 и могут лежать числа > k, но не само k.

---
## Решение задачи:  

Сначала переберём, где у нас будет стоять 0. Эти вершины не должны иметь рёбер между собой, а все остальные вершины должны иметь ребро хотя-бы с одной из них. Теперь выбросим эти вершины и будем смотреть оставшиеся и уже там искать 0. Но по сути это будет 1, но так как мы выбросили нули, то можно сказать и так. И так на каждом шаге мы повторяем наш алгоритм. 

Как это реализовано:
Мы не строим все функции явно (это было бы экспоненциально дорого).  
Вместо этого мы считаем количество возможных комбинаций **рекурсивно по подграфам**.
- `mask` — множество вершин, которые ещё не получили значение (ещё «живы»).
- `solve(mask)` возвращает количество способов корректно назначить значения f(v) этим вершинам.
- `cover[s]` - маска всех, кто имеет соседа в s
- `in_depend[s]` - независимое множество вершин s (не имеют между собой рёбра)

Предпосчитываем значения `cover` и `in_depend` ну и потом рекурсией считаем все возможные варианты разбиения на множества. 

Асимптотика - $O(n^3)$

--- 
## Код:

```C++
#include<iostream>
#include<vector>
#include<map>
#include<unordered_map>
#include<set>
#include<bitset>
#include<stack>
#include<queue>
#include<string>
#include<list>
#include<algorithm>
#include<cmath>
#include<numeric>
#include<iterator>
#include<iomanip>
#include<cassert>
#include<functional>
#include<random>
#include<ctime>
#include<unordered_set>
//#pragma GCC optimize("Ofast,unroll-loops")
//#pragma GCC target("avx,avx2,fma")
#define int long long

using ll = long long;
using namespace std;

mt19937 rnd(time(NULL));

const int MAXN = 3e5 + 3, INF = 1e18, MAXA = 1e6 + 3, MOD = 1e9 + 7;
const long double PI = acos(-1);

void solve() {
    using ull = unsigned long long;

    int n, m;
    cin >> n >> m;
    vector<int> adj(n);
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        u--;
        v--;
        adj[u] |= (1ll << v);
        adj[v] |= (1ll << u);
    }
    
    int N = (1ll << n);
    vector<char> is_indep(N);
    vector<int> cover(N);

    is_indep[0] = 1;
    for (int s = 1; s < N; s++) {
        int lb = s & -s; // берём первый ненулевой бит
        int v = __builtin_ctz(lb); // находим индекс этого бита - это наша вершина
        int s_without_v = s ^ lb; // множество без этой вершины

        // оно независимо, если независимо без v и нет рёбер среди этого множества и соседей v
        if (is_indep[s_without_v] && ((adj[v] & s_without_v) == 0)) 
            is_indep[s] = 1;
        else
            is_indep[s] = 0;
        
        // это множество покрывает вершины множества, которые покрывают вершины без v 
        // и само v и всех соседей v
        cover[s] = cover[s_without_v] | adj[v];
    }

    // это типа заглушка
    const ull UNVIS = numeric_limits<ull>::max();
    vector<ull> memo(N, UNVIS);
    memo[0] = 1; // базовый случай

    function<ull(int)> dfs = [&](int mask) {
        if (memo[mask] != UNVIS) // уже проверяли эту маску, значит возвращаем её
            return memo[mask];

        ull res = 0;
        for (int s = mask; s; s = (s - 1) & mask) { // трюк, на проверку всех подмножеств s только из единиц
            if (!is_indep[s])
                continue;

            int rest = mask ^ s; // множество вершин без s
            
            // ~cover[s] - не имеет соседа в s
            if ((rest & (~cover[s])) == 0) // оно не должно иметь соседей с s
                res += dfs(rest); // значит «все вершины вне s имеют хотя бы одного соседа в s».
        }

        memo[mask] = res;
        return res;
    };

    ull ans = dfs(N - 1);
    cout << ans << '\n';
}

signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    //freopen("basis.in", "r", stdin);
    //freopen("basis.out", "w", stdout);
    int t;
    t = 1;
    //cin >> t;
    while (t--)
        solve();
    return 0;
}
```
---