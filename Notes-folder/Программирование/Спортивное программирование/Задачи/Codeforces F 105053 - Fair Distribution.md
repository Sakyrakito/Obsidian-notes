# Дата - 2025-12-06

[Ссылка на задачу](https://codeforces.com/group/iXXb99K5SD/contest/105053/problem/F)

Tags: #спортивное_программирование #дп #теория_чисел

---
## О чём задача:

Даны N зданий. Для каждого здания известно, что высота его первого этажа равна G. Так же, мы должны как минимум 1 раз поставить на первый этаж, другой этаж высоты R. Этаж высоты R мы можем ставить сколько угодно раз, но как минимум 1, а первый этаж стоит обязательно и только 1 раз. 

У нас есть 2 рабочих. Мы должны распределить все наши здания среди них таким образом, чтобы каждое здание принадлежало только одному рабочему, и достраивая этажи на какие либо здания любое количество раз, они могла сделать так, чтобы суммарная высота их зданий были равны.

Рассмотрим случай для N = 3:
1. $G = 1$ и $R = 1$ (возможные высоты 2, 3, 4, ...)
2. $G = 0$ и $R = 3$ (возможные высоты 3, 6, 9, ...)
3. $G = 2$ и $R = 1$ (возможные высоты 3, 4, 5, ...)

В этом случае мы первому челу можем дать первое и третье здание, а второму второе. Тогда второй достраивает 2 этаже, а первый на первом здании достраивает 2 этаже, а на третьем 1 и сумма высот у первого равна 6 и у второго тоже 6.

$$
1 \leq N\leq 2*10^5 
$$
$$
(0 \leq G\leq 2*10^5)\ и\ (1\leq R\leq 10^9)
$$
$$
\sum_{i=1}^{N}G_{i} \leq 2 * 10^5
$$

---
## Решение задачи:  

Заметим, что если у нас все G равны, то мы можем 100% можем построить здания одинаковых высот просто взяв $lcm$ от всех R. То есть наш ответ зависит от G. Если у нас есть 2 здания высоты G1 и G2, то, чтобы мы могли сделать их высоты равными, мы должны с помощью наших R компенсировать разность их высот G1 - G2. Мы можем сделать это в том случае, когда $|G_{1} - G_{2}| = 0 \vdots gcd(R_{1}, R_{2})$. Если это не выполняется, то мы не сможем достроить наши здания до высоты $lcm(R_{1}, R_{2})$, так как здания всегда будут отличаться хотя бы на $|G_{1} - G_{2}|$. Если мы расширим это до массивов из множества элементов, то должно выполняться следующее: $$\left|\sum_{i=1}^{m_{1}}G_{i} - \sum_{j=1}^{m_{2}}G_{j} \right| = 0 \vdots gcd\left( R_{1}, R_{2}, R_{3}, \dots R_{n} \right)$$
Где $m_{1}$ - количество элементов первого чела, а $m_{2}$ - количество элементов второго чела.

Если gcd по всем R мы легко можем посчитать, просто пройдя по массиву, то выбрать, какие здания отдаём первому челу, а какие второму уже не просто. По сути нужно просто написать рюкзак и проверить суммы, которые мы можем набрать. Пусть первая сумма равна *x*, тогда вторая сумма $x - \sum G_{i}$. Но обычный рюкзак не зайдёт, так как ограничения слишком большие, поэтому мы напишем [[Рюкзак за Ssqrt(S)]] и тогда наша задача зайдет

--- 
## Код:

```c++
#include<iostream>
#include<vector>
#include<map>
#include<unordered_map>
#include<set>
#include<bitset>
#include<stack>
#include<queue>
#include<string>
#include<list>
#include<algorithm>
#include<cmath>
#include<numeric>
#include<iterator>
#include<iomanip>
#include<cassert>
#include<functional>
#include<random>
#include<ctime>
#include<unordered_set>
//#pragma GCC optimize("Ofast,unroll-loops")
//#pragma GCC target("avx,avx2,fma")
#define int long long

using namespace std;

mt19937 rnd(time(NULL));

const int MAXN = 3e5 + 3, INF = 2e18, MAXA = 1e6 + 3, MOD = 998'244'353;
const double PI = acos(-1);

void solve() {
    int n; cin >> n;
    int gc = 0;
    map<int, int> cnt;
    int sm = 0;
    bool flag = false;
    for (int i = 0; i < n; i++) {
        int g, r;
        cin >> g >> r;
        cnt[g]++;
        gc = gcd(gc, r);
        sm += g;
        if (g == 0)
            flag = true;
    }

    vector<int> vc;
    for (auto [x, k] : cnt) {
        int t = (int)log2(k + 1);
        int p = 1;
        vc.push_back(x);
        for (int i = 1; i < t; i++) {
            p *= 2;
            vc.push_back(p * x);
        }
        if (x * (k + 1 - (1ll << p)) != 0)
            vc.push_back(x * (k + 1 - (1ll << p)));
    }

    bitset<200'001> bt;
    bt[0] = 1;
    for (auto x : vc) {
        bt |= (bt << x);
    }

    for (int i = 0; i <= 200'000; i++) {
        if (!bt[i])
            continue;

        int sm1 = i, sm2 = sm - i;
        if ((sm1 == 0 || sm2 == 0) && abs(sm1 - sm2) % gc == 0) {
            if (flag) {
                cout << "Y\n";
                return;
            }
            continue;
        }

        if (abs(sm1 - sm2) % gc == 0) {
            cout << "Y\n";
            return;
        }
    }
    cout << "N\n";
}

signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    //freopen("basis.in", "r", stdin);
    //freopen("basis.out", "w", stdout);
    int t;
    t = 1;
    //cin >> t;
    while (t--)
        solve();
    return 0;
}
```
---