>[!info]
>Хэш работает на отрезке \[i, j]

C++:
```c++
using ull = uint64_t;
using myHash = std::pair<int, ull>;

struct pair_hash {
    size_t operator()(const myHash& p) const {
        return hash<int>()(p.first) ^ (hash<ull>()(p.second) << 1);
    }
};

myHash operator*(myHash a, myHash b) {
    return { a.first * 1LL * b.first % MOD, a.second * b.second };
}

myHash operator+(myHash a, myHash b) {
    return { (0LL + a.first + b.first) % MOD, a.second + b.second };
}

myHash operator-(myHash a, myHash b) {
    return { (0LL + a.first - b.first + MOD) % MOD, a.second - b.second };
}

const std::vector<myHash> power = []() {
    std::mt19937 gen(time(NULL));
    int p = std::uniform_int_distribution<int>(MOD / 2, MOD - 2)(gen);
    if (p % 2 == 0) p++;
    std::vector<myHash> answer(MAXN, { 1,1 });
    for (int i = 1; i < MAXN; i++) {
        answer[i] = answer[i - 1] * myHash(p, p);
    }
    return answer;
}();

struct MyHash {
    std::vector<myHash> pref;

    MyHash(const string& s) {
        // создать структуру
        pref.assign(s.size() + 1, {0, 0});
        for (int i = 0; i < s.size(); i++) {
            pref[i + 1] = pref[i] * power[1] + myHash(s[i], s[i]);
        }
    }

    myHash getMyHash(int i, int j) const {
        if (i > j) return { 0, 0 };
        // считаем хэш на отрезке
        return pref[j + 1] - pref[i] * power[j - i + 1];
    }
};
```