>[!info]
>Алгоритм для нахождения максимального паросочетания, но в этой реализации можно находить минимальное покрытие вершин.

```c++
#include<iostream>
#include<vector>
#include<map>
#include<unordered_map>
#include<set>
#include<bitset>
#include<stack>
#include<queue>
#include<string>
#include<list>
#include<algorithm>
#include<cmath>
#include<numeric>
#include<iterator>
#include<iomanip>
#include<cassert>
#include<functional>
#include<random>
#include<ctime>
#include<bit>
#include<unordered_set>
//#pragma GCC optimize("Ofast,unroll-loops")
//#pragma GCC target("avx,avx2,fma")
#define int long long

using namespace std;

mt19937 rnd(time(NULL));

const int MAXN = 3e5 + 3, INF = 2e18, MAXA = 1e6 + 3, MOD = 998'244'353;
const double PI = acos(-1);

struct HopcroftKarp {
    int n, m; // n - левая доля, m - правая
    vector<vector<int>> g; // g[u] - список вершин правой доли, куда есть ребро
    vector<int> dist; // расстояние для BFS
    vector<int> pairL, pairR; // pairL[u] - с кем сматчена левая u, pairR[v] - правая, -1 - если свободна

    HopcroftKarp(int n, int m)
        : n(n), m(m)
    {
        g.resize(n);
        pairL.assign(n, -1);
        pairR.assign(m, -1);
        dist.resize(n);
    }

    void addEdge(int u, int v) {
        g[u].push_back(v);
    }

    // BFS ищет расстояние до "свободных" вершин правой доли
    bool bfs() {
        queue<int> q;

        for (int l = 0; l < n; l++) {
            if (pairL[l] == -1) { // свободная вершина левой доли
                dist[l] = 0;
                q.push(l);
            }
            else {
                dist[l] = INF;
            }
        }

        bool foundFreeR = false;

        while (!q.empty()) {
            int l = q.front();
            q.pop();

            for (auto r : g[l]) {
                int l2 = pairR[r]; // вершина левой доли, сматченная с r

                if (l2 != -1 && dist[l2] == INF) {
                    dist[l2] = dist[l] + 1;
                    q.push(l2);
                }

                if (l2 == -1) {
                    foundFreeR = true;
                }
            }
        }

        return foundFreeR;
    }

    // DFS ищет увеличивающие пути
    bool dfs(int l) {
        for (auto r : g[l]) {
            int l2 = pairR[r];

            if (l2 == -1 || (l2 != -1 && dist[l2] == dist[l] + 1 && dfs(l2))) {
                pairL[l] = r;
                pairR[r] = l;
                return true;
            }
        }

        dist[l] = INF;
        return false;
    }

    // основной метод
    int maxMatching() {
        int matching = 0;

        while (bfs()) {
            for (int l = 0; l < n; l++) {
                if (pairL[l] == -1 && dfs(l)) {
                    matching++;
                }
            }
        }

        return matching;
    }
};

void solve() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> country_colors(n);
    for (int i = 0; i < n; i++) {
        int k; cin >> k;
        country_colors[i].resize(k);
        for (int j = 0; j < k; j++) {
            int c; cin >> c;
            c--;
            country_colors[i][j] = c;
        }
    }

    HopcroftKarp hk(m, n); // слева цвета, справа страны
    for (int i = 0; i < n; i++) {
        for (int c : country_colors[i]) {
            hk.addEdge(c, i);
        }
    }

    int matching = hk.maxMatching();

    // находим минимальное покрытие вершин
    // начинаем со свободных левых
    vector<bool> visL(m), visR(n);
    queue<int> q;
    for (int l = 0; l < m; l++) {
        if (hk.pairL[l] == -1) {
            visL[l] = true;
            q.push(l);
        }
    }

    while (!q.empty()) {
        int l = q.front();
        q.pop();

        for (int r : hk.g[l]) {
            if (hk.pairL[l] != r && !visR[r]) {
                visR[r] = true;
                int l2 = hk.pairR[r];

                if (l2 != -1 && !visL[l2]) {
                    visL[l2] = true;
                    q.push(l2);
                }
            }
        }
    }

    int coverSize = 0;
    for (int l = 0; l < m; l++)
        if (!visL[l])
            coverSize++;
    for (int r = 0; r < n; r++)
        if (visR[r])
            coverSize++;

    cout << coverSize << '\n';
}

signed main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0); //cout.tie(0);
    //freopen("basis.in", "r", stdin);
    //freopen("basis.out", "w", stdout);
    int t;
    t = 1;
    //cin >> t;
    while (t--)
        solve();
    return 0;
}
```


