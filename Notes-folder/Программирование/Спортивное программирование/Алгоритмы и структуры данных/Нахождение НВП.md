>[!info]
>Нахождение наидлиннейшей возрастающей подпоследовательности за $n\log n$.
>
>По такой динамике тоже можно восстановить ответ, для чего опять же помимо динамики $d[i]$ также надо хранить массив "предков" $p[i]$ - то, на элементе с каким индексом оканчивается оптимальная подпоследовательность длины ![i](http://e-maxx.ru/tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png). Кроме того, для каждого элемента массива $a[i]$ надо будет хранить его "предка" — т.е. индекс того элемента, который должен стоять перед $a[i]$ в оптимальной подпоследовательности.

```c++
int d[MAXN];
d[0] = -INF;
for (int i=1; i<=n; ++i)
	d[i] = INF;
 
for (int i=0; i<n; i++) {
	int j = int (upper_bound (d.begin(), d.end(), a[i]) - d.begin());
	if (d[j-1] < a[i] && a[i] < d[j])
		d[j] = a[i];
```