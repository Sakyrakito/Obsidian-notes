>[!info]
>Алгоритм на нахождение максимального потока и минимального разреза в графе
>([[алгоритм Диница (Dinic)]] лучше по асимптотике)

```C++
class FordFulkerson {
private:
	const int INF = 1e9;
	int n;
	
	vector<vector<int>> cap;
	vector<vector<int>> res;

	bool bfs(int source, int sink, vector<int>& parent) {
		vector<bool> vis(n);
		vector<int> vc = { source };

		vis[source] = true;
		parent[source] = -1;

		for (int i = 0; i < vc.size(); i++) {
			for (int j = 0; j < n; j++) {
				if (!vis[j] && res[vc[i]][j] > 0) {
					vis[j] = true;
					parent[j] = vc[i];
					vc.push_back(j);

					if (j == sink)
						return true;
				}
			}
		}

		return false;
	}

public:
	FordFulkerson(int n) {
		this->n = n;
		cap.resize(n, vector<int>(n));
		res.resize(n, vector<int>(n));
	}

	void addEdge(int u, int v, int w) {
		cap[u][v] = w;
		res[u][v] = w;
	}

	int findMaxFlow(int source, int sink) {
		vector<int> parent(n);
		int maxFlow = 0;

		while (bfs(source, sink, parent)) {
			int pathFlow = INF;

			for (int i = sink; i != source;) {
				int j = parent[i];
				pathFlow = min(pathFlow, res[j][i]);
				i = j;
			}

			for (int i = sink; i != source;) {
				int j = parent[i];

				res[j][i] -= pathFlow;
				res[i][j] += pathFlow;
				i = j;
			}

			maxFlow += pathFlow;
		}

		return maxFlow;
	}

	vector<pair<int, int>> findMinCut(int source, int sink) {
		res = cap;
		int maxFlow = findMaxFlow(source, sink);

		vector<bool> visited(n, false);
		queue<int> q;
		q.push(source);
		visited[source] = true;

		while (!q.empty()) {
			int u = q.front();
			q.pop();

			for (int v = 0; v < n; v++)
				if (!visited[v] && res[u][v] > 0) {
					visited[v] = true;
					q.push(v);
				}
		}

		vector<pair<int, int>> minCut;
		for (int u = 0; u < n; u++)
			for (int v = 0; v < n; v++)
				if (visited[u] && !visited[v] && cap[u][v] > 0)
					minCut.push_back({ u, v });

		return minCut;
	}
};
```